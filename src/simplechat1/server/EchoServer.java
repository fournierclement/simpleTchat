package server;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import ocsf.server.*;import java.net.*;import java.util.ArrayList;import java.util.Observable;import java.util.Observer;import com.sun.corba.se.spi.activation.Server;import common.ChatIF;/** * This class overrides some of the methods in the abstract superclass in order * to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements ChatIF, Observer {	// Class variables *************************************************	/**	 * The default port to listen on.	 */	final public static int DEFAULT_PORT = 5555;	final public static String MESSAGE_SERVER = "Server MSG> ";	ObservableOriginatorServer OOServ;			// Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port	 *            The port number to connect on.	 * @throws IOException 	 */	public EchoServer(int port) throws IOException {		OOServ = new ObservableOriginatorServer(port);		OOServ.addObserver(this);		OOServ.listen();	}	// Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 *	 * @param msg	 *            The message received from the client.	 * @param client	 *            The connection from which the message originated.	 */	public void handleMessageFromClient(Object msg, ConnectionToClient client) {		if (((String)msg).split(" ")[0].equals("#login")){			if(client.getInfo("id") == null) {				client.setInfo("id", ((String)msg).split(" ")[1]);				OOServ.sendToAllClients(client + " Is Now Known as " + client.getInfo("id"));				this.display(client + " Is Now Known as " + client.getInfo("id"));							} else {				clientException(client, new Exception("You are already logged in, silly !"));			}		} else if (client.getInfo("id") != null){			OOServ.sendToAllClients(client.getInfo("id") +" > " + msg);				this.display(client.getInfo("id") +" > " + msg);		} else {			clientException(client, new Exception("You need to log in right now !"));			try {				client.close();			} catch (IOException e) {				e.printStackTrace();			}		}	}	/**	 * This method overrides the one in the superclass. Called when the server	 * starts listening for connections.	 */	protected void serverStarted() {		display("Server listening for connections on port "				+ OOServ.getPort());	}	/**	 * This method overrides the one in the superclass. Called when the server	 * stops listening for connections.	 */	protected void serverStopped() {		display("Server has stopped listening for connections.");	}		protected void serverClosed() {		display("Server has been closed.");	}	// Class methods ***************************************************	/**	 * This method is responsible for the creation of the server instance (there	 * is no UI in this phase).	 *	 * @param args	 *            [0] The port number to listen on. Defaults to 5555 if no	 *            argument is entered.	 */	public static void main(String[] args) {		int port = 0; // Port to listen on		try {			port = Integer.parseInt(args[0]); // Get port from command line		} catch (Throwable t) {			port = DEFAULT_PORT; // Set port to 5555		}			try {				EchoServer sv = new EchoServer(port);				BufferedReader fromConsole = new BufferedReader(					new InputStreamReader(System.in));				String message;				while (true) {					message = fromConsole.readLine();					sv.handleMessageFromServer(message);				}			} catch (Exception e) {				// TODO Auto-generated catch block				e.printStackTrace();			}	}	private void handleMessageFromServer(String message) {		if (message.charAt(0) == '#') {			whatIs(message);		} else {			OOServ.sendToAllClients(MESSAGE_SERVER +  message);		}			}	/**	 * Hook method called each time an exception is thrown in a	 * ConnectionToClient thread. The method may be overridden by subclasses but	 * should remains synchronized.	 *	 * @param client	 *            the client that raised the exception.	 * @param Throwable	 *            the exception thrown.	 */	synchronized protected void clientException(ConnectionToClient client,			Throwable exception) {		try {			client.sendToClient(exception.getMessage());		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}	}	/**	 * Hook method called each time a new client connection is accepted. The	 * default implementation does nothing.	 * 	 * @param client	 *            the connection connected to the client.	 */	protected void clientConnected(ConnectionToClient client) {		display(client + " is connected \\o/");	}	/**	 * Hook method called each time a client disconnects. The default	 * implementation does nothing. The method may be overridden by subclasses	 * but should remains synchronized.	 *	 * @param client	 *            the connection with the client.	 */	synchronized protected void clientDisconnected(ConnectionToClient client) {		display (client.getInfo("id") + " is disconnected  :c");			}		private void whatIs(String message) {		String[] splittedMessage = message.split(" "); // Only the condition we														// want to see.		switch (splittedMessage[0]) {		case "#quit":			this.quit();			break;		case "#stop":				OOServ.stopListening();			break;		case "#close":			try {				OOServ.close();			} catch (IOException e) {				e.printStackTrace();			}			break;		case "#setport":			OOServ.setPort(Integer.parseInt(splittedMessage[1]));			break;		case "#start":			try {				OOServ.listen();			} catch (IOException e1) {				e1.printStackTrace();			}			break;		case "#getport":			display(""+OOServ.getPort());			break;		}	}	private void quit() {		System.exit(0);	}	@Override	public void display(String message) {		System.out.println(message);			}	@Override	public void update(Observable o, Object arg) {		OriginatorMessage origin = (OriginatorMessage) arg;		if ( origin.getMessage().equals(OOServ.CLIENT_CONNECTED)) {			clientConnected(origin.getOriginator());		}		else if (origin.getMessage().equals(OOServ.CLIENT_DISCONNECTED)) {			clientDisconnected(origin.getOriginator());		}		else if (((String) origin.getMessage()).contains(OOServ.CLIENT_EXCEPTION)) {			clientException(origin.getOriginator(), new Exception( (String) origin.getMessage()));		}		else if (origin.getMessage().equals(OOServ.SERVER_CLOSED)) {			serverClosed();		}		else if (origin.getMessage().equals(OOServ.SERVER_STARTED)) {			serverStarted();		}		else if (origin.getMessage().equals(OOServ.SERVER_STOPPED)) {			serverStopped();		}		else {			handleMessageFromClient( (String) origin.getMessage(), origin.getOriginator() ); 		}	}}// End of EchoServer class