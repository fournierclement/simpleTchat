// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import ocsf.server.*;import java.net.*;import java.util.ArrayList;import com.sun.corba.se.spi.activation.Server;import common.ChatIF;/** * This class overrides some of the methods in the abstract superclass in order * to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer extends AbstractServer implements ChatIF {	// Class variables *************************************************	/**	 * The default port to listen on.	 */	final public static int DEFAULT_PORT = 5555;	private ArrayList<InetAddress> clients;	final public static String MESSAGE_SERVER = "Server MSG>";	// Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port	 *            The port number to connect on.	 */	public EchoServer(int port) {		super(port);		clients = new ArrayList<InetAddress>();	}	// Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 *	 * @param msg	 *            The message received from the client.	 * @param client	 *            The connection from which the message originated.	 */	public void handleMessageFromClient(Object msg, ConnectionToClient client) {		if (((String)msg).split(" ")[0].equals("#login")){			if(client.getInfo("id") == null) {				client.setInfo("id", ((String)msg).split(" ")[1]);				this.sendToAllClients(client + " Is Now Known as " + client.getInfo("id"));				this.display(client + " Is Now Known as " + client.getInfo("id"));							} else {				clientException(client, new Exception("You are already logged in, silly !"));			}		} else if (client.getInfo("id") != null){			this.sendToAllClients(client.getInfo("id") +" > " + msg);				this.display(client.getInfo("id") +" > " + msg);		} else {			clientException(client, new Exception("You need to log in right now !"));			try {				client.close();			} catch (IOException e) {				e.printStackTrace();			}		}	}	/**	 * This method overrides the one in the superclass. Called when the server	 * starts listening for connections.	 */	protected void serverStarted() {		System.out.println("Server listening for connections on port "				+ getPort());	}	/**	 * This method overrides the one in the superclass. Called when the server	 * stops listening for connections.	 */	protected void serverStopped() {		System.out.println("Server has stopped listening for connections.");	}	// Class methods ***************************************************	/**	 * This method is responsible for the creation of the server instance (there	 * is no UI in this phase).	 *	 * @param args	 *            [0] The port number to listen on. Defaults to 5555 if no	 *            argument is entered.	 */	public static void main(String[] args) {		int port = 0; // Port to listen on		try {			port = Integer.parseInt(args[0]); // Get port from command line		} catch (Throwable t) {			port = DEFAULT_PORT; // Set port to 5555		}		EchoServer sv = new EchoServer(port);		try {			sv.listen(); // Start listening for connections		} catch (Exception ex) {			System.out.println("ERROR - Could not listen for clients!");		}		try {			BufferedReader fromConsole = new BufferedReader(					new InputStreamReader(System.in));			String message;			while (true) {				message = fromConsole.readLine();				if (message.charAt(0) == '#') {					sv.whatIs(message);				} else {					sv.sendToAllClients(MESSAGE_SERVER +  message);				}			}		} catch (Exception ex) {			System.out.println("Unexpected error while reading from console!");		}	}	/**	 * Hook method called each time an exception is thrown in a	 * ConnectionToClient thread. The method may be overridden by subclasses but	 * should remains synchronized.	 *	 * @param client	 *            the client that raised the exception.	 * @param Throwable	 *            the exception thrown.	 */	synchronized protected void clientException(ConnectionToClient client,			Throwable exception) {	}	/**	 * Hook method called each time a new client connection is accepted. The	 * default implementation does nothing.	 * 	 * @param client	 *            the connection connected to the client.	 */	protected void clientConnected(ConnectionToClient client) {		System.out.println(client + " is connected \\o/");	}	/**	 * Hook method called each time a client disconnects. The default	 * implementation does nothing. The method may be overridden by subclasses	 * but should remains synchronized.	 *	 * @param client	 *            the connection with the client.	 */	synchronized protected void clientDisconnected(ConnectionToClient client) {		System.out.println(client + " is disconnected  :c");			}		private void whatIs(String message) {		String[] splittedMessage = message.split(" "); // Only the condition we														// want to see.		switch (splittedMessage[0]) {		case "#quit":			this.quit();			break;		case "#stop":				this.stopListening();			break;		case "#close":			try {				this.close();			} catch (IOException e) {				e.printStackTrace();			}			break;		case "#setport":			this.setPort(Integer.parseInt(splittedMessage[1]));			break;		case "#start":			try {				this.listen();			} catch (IOException e1) {				e1.printStackTrace();			}			break;		case "#getport":			System.out.println(this.getPort());			break;		}	}	@Override	public void display(String message) {		System.out.println(message);			}}// End of EchoServer class